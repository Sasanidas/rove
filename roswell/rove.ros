#!/bin/sh
#|-*- mode:lisp -*-|#
#| Run tests with Rove.
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  (ql:quickload '(:rove) :silent t)
  #+sbcl (require 'sb-cover)

  (when (and (stringp (ros:getenv "COVERAGE"))
             (string/= (ros:getenv "COVERAGE") ""))
    (ql:quickload :split-sequence :silent t)))

(defpackage :ros.script.roswell/rove.3697685121
  (:use :cl))
(in-package :ros.script.roswell/rove.3697685121)

(defun get-real-stream (stream)
  (if (typep stream 'synonym-stream)
      (symbol-value (synonym-stream-symbol stream))
      stream))

(defun run-file-tests (file)
  (let ((tries-so-far (make-hash-table :test 'equalp))
        (rove/core/suite:*rove-standard-output* (get-real-stream *standard-output*))
        (rove/core/suite:*rove-error-output* (get-real-stream *error-output*))
        (*standard-output* (make-broadcast-stream))
        (system-name (cond
                       ((equal (pathname-type file) "lisp")
                        (let ((*print-case* :downcase))
                          (princ-to-string
                           (second (asdf/package-inferred-system::file-defpackage-form file)))))
                       ((equal (pathname-type file) "asd")
                        (pathname-name file)))))
    (tagbody retry
       (handler-case
           (progn
             (locally
                 (declare #+sbcl (sb-ext:muffle-conditions cl:warning))
               (handler-bind ((cl:warning #'muffle-warning))
                 (asdf:load-system system-name)))
             (asdf:test-system system-name)
             (unless rove/core/suite:*last-suite-report*
               (rove:run system-name)))
         (asdf:missing-dependency (c)
           (let ((missing (asdf::missing-requires c)))
             (when (gethash missing tries-so-far)
               (error "Cannot load a dependency ~A, which is required by ~A"
                      missing (asdf::missing-required-by c)))
             (setf (gethash missing tries-so-far) t)
             (ql:quickload missing :silent t)
             (go retry)))))
    (first rove/core/suite:*last-suite-report*)))

(defmacro case-equal (keyform &body cases)
  (let ((g-keyform (gensym "KEYFORM")))
    `(let ((,g-keyform ,keyform))
       (cond
         ,@(loop for (case . body) in cases
                 if (eq case 'otherwise)
                   collect `(t ,@body)
                 else
                   collect `((find ,g-keyform ',(if (listp case)
                                                    case
                                                    (list case))
                                   :test #'equal)
                             ,@body))))))

(defun parse-argv (argv)
  (loop for option = (pop argv)
        while option
        do (case-equal option
             (("-r" "--reporter")
              (setf rove:*default-reporter* (intern (string-upcase (pop argv)) :keyword)))
             (otherwise
              (return (cons option argv))))))

(defun print-usage ()
  (format *error-output* "~&Usage: rove [option...] test-file

Options:
    -r, --reporter REPORTER-NAME    Reporter style (one of \"spec\" or \"none\")
"))

#+sbcl
(eval-when (:compile-toplevel :load-toplevel :execute)
  (when (and (stringp (uiop:getenv "COVERAGE"))
             (string/= (uiop:getenv "COVERAGE") ""))
    (declaim (optimize sb-cover:store-coverage-data))))

(defun pathname-in-directory-p (path directory)
  (flet ((ensure-string (v)
           (etypecase v
             (string v)
             (pathname (namestring v)))))
    (let ((path (ensure-string path))
          (directory (ensure-string directory)))
      (and (< (length directory) (length path))
           (string= directory path :end2 (length directory))))))

(defun main (&rest argv)
  (let* ((target-files (parse-argv argv))
         (target (first target-files)))
    (unless target
      (print-usage)
      (uiop:quit -1))
    (let ((file (probe-file target)))
      (unless file
        (format *error-output* "~&Error: ~A not found.~%" target)
        (print-usage)
        (uiop:quit -1))
      (unless (member (pathname-type file) '("lisp" "asd")
                      :test #'string=)
        (format *error-output* "~&Error: Invalid file type.~%")
        (uiop:quit -1))

      (unwind-protect
           (or (run-file-tests file)
               (uiop:quit -1))
        #+sbcl
        (when (and (stringp (ros:getenv "COVERAGE"))
                   (string/= (ros:getenv "COVERAGE") ""))
          (let ((dir (merge-pathnames #P"report/"))
                (excludes (mapcar (lambda (exclude)
                                    (uiop:ensure-directory-pathname
                                     (merge-pathnames exclude (uiop:pathname-directory-pathname file))))
                                  (uiop:symbol-call :split-sequence :split-sequence
                                                    #\: (or (uiop:getenv "COVERAGE_EXCLUDE") "")
                                                    :remove-empty-subseqs t))))
            (format *error-output* "~&Coverage report: '~Acover-index.html'~%" dir)
            (locally
                (declare #+sbcl (sb-ext:muffle-conditions cl:warning))
              (handler-bind ((cl:warning #'muffle-warning))
                (sb-cover:report dir
                                 :if-matches
                                 (lambda (path)
                                   (not (some (lambda (exclude)
                                                (pathname-in-directory-p path exclude))
                                              excludes))))))))))))
;;; vim: set ft=lisp lisp:
